+ :
++ echo http://example.com
++ bin/pq.py --py

isplits = iline.split("/")
osplits = list(isplits)
osplits[0] = osplits[0].replace(":", " :")  # https ://
osplits[2] = " " + osplits[2].replace(".", " . ") + " "  # :// sub . domain
oline = "/".join(osplits).strip()

+ T=
++ echo http://example.com
++ bin/pq.py --yolo
+ T='http :// example . com'
++ echo http :// example . com
++ bin/pq.py --py

oline = "".join(iwords)

+ T=
++ echo http :// example . com
++ bin/pq.py --yolo
+ T=http://example.com
+ :
+ A=https://codereviews.example.com/r/123456
++ echo https://codereviews.example.com/r/123456/
++ bin/pq.py --py

isplits = urllib.parse.urlsplit(iline)
m = re.match(r"^/r/([0-9]+)", string=isplits.path)  # discards end of path
r = int(m.group(1))
osplits = urllib.parse.SplitResult(
    scheme="http",  # not "https"
    netloc=isplits.netloc.split(".")[0],  # "codereviews"
    path=f"/r/{r}/diff",
    query="",
    fragment="",
)
oline = osplits.geturl()

+ T=
++ echo https://codereviews.example.com/r/123456/
++ bin/pq.py --yolo
+ T=http://codereviews/r/123456/diff
+ :
+ A=https://docs.google.com/document/d/1YfkPxiJjVJXvf4G1-Ql6-IgxE7J22eEG2JzueNjl2T4
++ echo https://docs.google.com/document/d/1YfkPxiJjVJXvf4G1-Ql6-IgxE7J22eEG2JzueNjl2T4/edit#heading=h.xedwnjmaewr
++ bin/pq.py --py

isplits = urllib.parse.urlsplit(iline)
ipath = isplits.path

opath = ipath
opath = opath.removesuffix("/edit")
opath = opath.removesuffix("/view")

osplits = urllib.parse.SplitResult(
    scheme=isplits.scheme,
    netloc=isplits.netloc,
    path=opath,
    query="",
    fragment="",
)
oline = osplits.geturl()

+ T=
++ echo https://docs.google.com/document/d/1YfkPxiJjVJXvf4G1-Ql6-IgxE7J22eEG2JzueNjl2T4/edit#heading=h.xedwnjmaewr
++ bin/pq.py --yolo
+ T=https://docs.google.com/document/d/1YfkPxiJjVJXvf4G1-Ql6-IgxE7J22eEG2JzueNjl2T4
+ :
+ A=https://ourjenkins.dev.example.com
++ echo https://ourjenkins.dev.example.com/
++ bin/pq.py --py

isplits = urllib.parse.urlsplit(iline)
sub = isplits.netloc.split(".")[0]
osplits = urllib.parse.SplitResult(
    scheme="http",
    netloc=sub.casefold().replace("jenkins", "Jenkins"),
    path=isplits.path,
    query=isplits.query,
    fragment=isplits.fragment,
)
oline = osplits.geturl()

+ T=
++ echo https://ourjenkins.dev.example.com/
++ bin/pq.py --yolo
+ T=http://ourJenkins/
+ A=http://ourJenkins/
++ echo http://ourJenkins//
++ bin/pq.py --py

isplits = urllib.parse.urlsplit(iline)
fqdn = socket.getfqdn()
dn = fqdn.partition(".")[-1]  # Domain Name of HostName
dn = dn or "example.com"
osplits = urllib.parse.SplitResult(
    scheme="https",
    netloc=f"{isplits.netloc}.dev.{dn}".casefold(),
    path=isplits.path.removesuffix("/"),
    query=isplits.query,
    fragment=isplits.fragment,
)
oline = osplits.geturl()

+ T=
++ echo http://ourJenkins//
++ bin/pq.py --yolo
+ T=https://ourjenkins.dev.example.com/
+ :
+ A=https://jira.example.com/browse/PROJ-123456
++ echo https://jira.example.com/browse/PROJ-123456
++ bin/pq.py --py

isplits = urllib.parse.urlsplit(iline)
oline = isplits.path.removeprefix("/browse/")  # 'PROJ-12345'

+ T=
++ echo https://jira.example.com/browse/PROJ-123456
++ bin/pq.py --yolo
+ T=PROJ-123456
+ A=PROJ-123456
++ echo PROJ-123456
++ bin/pq.py --py

isplits = urllib.parse.urlsplit(iline)
fqdn = socket.getfqdn()
dn = fqdn.partition(".")[-1]  # Domain Name of HostName
dn = dn or "example.com"
osplits = urllib.parse.SplitResult(
    scheme="https",
    netloc=f"jira.{dn}",
    path=f"/browse/{iline}",
    query="",
    fragment="",
)
oline = osplits.geturl()

+ T=
++ echo PROJ-123456
++ bin/pq.py --yolo
+ T=https://jira.example.com/browse/PROJ-123456
+ :
++ echo '{"//":[""]}'
++ bin/pq.py --py j

itext = ibytes.decode()
otext = json.dumps(json.loads(itext), indent=2) + "\n"  # |jq .  # jq
obytes = otext.encode()

+ T=
++ echo '{"//":[""]}'
++ bin/pq.py jq
++ cat -
+ T='{
  "//": [
    ""
  ]
}'
+ :
+ echo '{
  "//": [
    ""
  ]
}'
+ :
+ echo +
+
+ func bytes len
+ set -xe
+ bin/pq.py --py bytes len

oline = str(len(ibytes))  # bytes len  # |wc -c  # wc c  # wcc

olines = [oline]
otext = "\n".join(olines) + "\n"
obytes = otext.encode()

+ func text len
+ set -xe
+ bin/pq.py --py text len

itext = ibytes.decode()

oline = str(len(itext))  # text characters len  # |wc -m  # wc m  # wcm

olines = [oline]
otext = "\n".join(olines) + "\n"
obytes = otext.encode()

+ func lines len
+ set -xe
+ bin/pq.py --py lines len

itext = ibytes.decode()

oline = str(len(itext.splitlines()))  # lines len  # |wc -l  # wc l  # wcl

olines = [oline]
otext = "\n".join(olines) + "\n"
obytes = otext.encode()

+ func words len
+ set -xe
+ bin/pq.py --py words len

itext = ibytes.decode()

oline = str(len(itext.split()))  # words len  # |wc -w  # wc w  # wcw

olines = [oline]
otext = "\n".join(olines) + "\n"
obytes = otext.encode()

+ func ascii
+ set -xe
+ bin/pq.py --py ascii

itext = ibytes.decode()
ilines = itext.splitlines()
olines = list()
for iline in ilines:

    oline = ascii(iline)  # |cat -tv, but don't show $'\xA0' as $'\x20' Space
    olines.append(oline)

otext = "\n".join(olines) + "\n"
obytes = otext.encode()

+ func eval
+ set -xe
+ bin/pq.py --py eval

itext = ibytes.decode()
ilines = itext.splitlines()
olines = list()
for iline in ilines:

    oline = ast.literal_eval(iline)  # undo 'ascii' or 'repr'
    olines.append(oline)

otext = "\n".join(olines) + "\n"
obytes = otext.encode()

+ func join
+ set -xe
+ bin/pq.py --py join

itext = ibytes.decode()
ilines = itext.splitlines()

oline = " ".join(ilines)  # joined  # |tr '\n' ' '  # |xargs  # x x

olines = [oline]
otext = "\n".join(olines) + "\n"
obytes = otext.encode()

+ func repr
+ set -xe
+ bin/pq.py --py repr

itext = ibytes.decode()
ilines = itext.splitlines()
olines = list()
for iline in ilines:

    oline = repr(iline)  # undo 'ast.literal_eval'
    olines.append(oline)

otext = "\n".join(olines) + "\n"
obytes = otext.encode()

+ func set
+ set -xe
+ bin/pq.py --py set

itext = ibytes.decode()
ilines = itext.splitlines()

# collections.Counter.keys, set, uniq, uniq_everseen, unsorted
olines = list(dict((_, _) for _ in ilines).keys())

otext = "\n".join(olines) + "\n"
obytes = otext.encode()

+ func split
+ set -xe
+ bin/pq.py --py split

itext = ibytes.decode()

olines = itext.split()  # |xargs -n 1  # |xn1  # split

otext = "\n".join(olines) + "\n"
obytes = otext.encode()

+ func close
+ set -xe
+ bin/pq.py --py close

itext = ibytes.decode()

# closed # close  # ends last line with "\n"
otext = itext if itext.endswith("\n") else (itext + "\n")

obytes = otext.encode()

+ func dedent
+ set -xe
+ bin/pq.py --py dedent

itext = ibytes.decode()
otext = textwrap.dedent(itext) + "\n"  # dedented
obytes = otext.encode()

+ func deframe
+ set -xe
+ bin/pq.py --py deframe

itext = ibytes.decode()

# deframe  # deframed
otext = textwrap.dedent(itext) + "\n"  # no left margin
olines = otext.splitlines()
olines = list(_.rstrip() for _ in olines)  # no right margin
otext = "\n".join(olines).strip() + "\n"  # no top/bottom margins

obytes = otext.encode()

+ func dent
+ set -xe
+ bin/pq.py --py dent

itext = ibytes.decode()
ilines = itext.splitlines()
olines = list()
for iline in ilines:

    oline = (4 * " ") + iline  # as if textwrap.dented  # dent
    olines.append(oline)

otext = "\n".join(olines) + "\n"
obytes = otext.encode()

+ func frame
+ set -xe
+ bin/pq.py --py frame

itext = ibytes.decode()
ilines = itext.splitlines()

# frame  # framed
olines = list()
olines.extend(2 * [""])  # top margin
for iline in ilines:
    oline = (4 * " ") + iline  # left margin
    olines.append(oline)
olines.extend(2 * [""])  # bottom margin

otext = "\n".join(olines) + "\n"
obytes = otext.encode()

+ func end
+ set -xe
+ bin/pq.py --py end

itext = ibytes.decode()
ilines = itext.splitlines()

olines = ilines  # ended  # end  # ends every line with "\n"

otext = "\n".join(olines) + "\n"
obytes = otext.encode()

+ func lower
+ set -xe
+ bin/pq.py --py lower

itext = ibytes.decode()
otext = itext.lower()  # lowered lowercased  # |tr '[A-Z]' '[a-z]'
obytes = otext.encode()

+ func lstrip
+ set -xe
+ bin/pq.py --py lstrip

itext = ibytes.decode()
ilines = itext.splitlines()
olines = list()
for iline in ilines:

    oline = iline.lstrip()  # lstripped  # |sed 's,^ *,,'
    olines.append(oline)

otext = "\n".join(olines) + "\n"
obytes = otext.encode()

+ func reverse
+ set -xe
+ bin/pq.py --py reverse

itext = ibytes.decode()
ilines = itext.splitlines()

olines = reversed(ilines)  # reverse  # |tail -r  # tail r  # |tac  # tac

otext = "\n".join(olines) + "\n"
obytes = otext.encode()

+ func rstrip
+ set -xe
+ bin/pq.py --py rstrip

itext = ibytes.decode()
ilines = itext.splitlines()
olines = list()
for iline in ilines:

    oline = iline.rstrip()  # rstripped  # |sed 's, *$,,'
    olines.append(oline)

otext = "\n".join(olines) + "\n"
obytes = otext.encode()

+ func shuffle
+ set -xe
+ bin/pq.py --py shuffle

itext = ibytes.decode()
ilines = itext.splitlines()

olines = list(ilines); random.shuffle(olines)  # shuffled

otext = "\n".join(olines) + "\n"
obytes = otext.encode()

+ func sort
+ set -xe
+ bin/pq.py --py sort

itext = ibytes.decode()
ilines = itext.splitlines()

olines = sorted(ilines)  # sort  # s s

otext = "\n".join(olines) + "\n"
obytes = otext.encode()

+ func sponge
+ set -xe
+ bin/pq.py --py sponge

obytes = ibytes  # sponged  # sponge

+ func strip
+ set -xe
+ bin/pq.py --py strip

itext = ibytes.decode()
ilines = itext.splitlines()
olines = list()
for iline in ilines:

    oline = iline.strip()  # stripped  # |sed 's,^ *,,' |sed 's, *$,,'
    olines.append(oline)

otext = "\n".join(olines) + "\n"
obytes = otext.encode()

+ func title
+ set -xe
+ bin/pq.py --py title

itext = ibytes.decode()
otext = itext.title()  # titled
obytes = otext.encode()

+ func undent
+ set -xe
+ bin/pq.py --py undent

itext = ibytes.decode()
ilines = itext.splitlines()
olines = list()
for iline in ilines:

    oline = iline.removeprefix(4 * " ")  # as if textwrap.undented  # undent
    olines.append(oline)

otext = "\n".join(olines) + "\n"
obytes = otext.encode()

+ func upper
+ set -xe
+ bin/pq.py --py upper

itext = ibytes.decode()
otext = itext.upper()  # uppered uppercased  # |tr '[a-z]' '[A-Z]'
obytes = otext.encode()

+ func closed
+ set -xe
+ bin/pq.py --py closed

itext = ibytes.decode()

# closed # close  # ends last line with "\n"
otext = itext if itext.endswith("\n") else (itext + "\n")

obytes = otext.encode()

+ func dedented
+ set -xe
+ bin/pq.py --py dedented

itext = ibytes.decode()
otext = textwrap.dedent(itext) + "\n"  # dedented
obytes = otext.encode()

+ func deframed
+ set -xe
+ bin/pq.py --py deframed

itext = ibytes.decode()

# deframe  # deframed
otext = textwrap.dedent(itext) + "\n"  # no left margin
olines = otext.splitlines()
olines = list(_.rstrip() for _ in olines)  # no right margin
otext = "\n".join(olines).strip() + "\n"  # no top/bottom margins

obytes = otext.encode()

+ func dented
+ set -xe
+ bin/pq.py --py dented

itext = ibytes.decode()
ilines = itext.splitlines()
olines = list()
for iline in ilines:

    oline = (4 * " ") + iline  # as if textwrap.dented  # dent
    olines.append(oline)

otext = "\n".join(olines) + "\n"
obytes = otext.encode()

+ func ended
+ set -xe
+ bin/pq.py --py ended

itext = ibytes.decode()
ilines = itext.splitlines()

olines = ilines  # ended  # end  # ends every line with "\n"

otext = "\n".join(olines) + "\n"
obytes = otext.encode()

+ func framed
+ set -xe
+ bin/pq.py --py framed

itext = ibytes.decode()
ilines = itext.splitlines()

# frame  # framed
olines = list()
olines.extend(2 * [""])  # top margin
for iline in ilines:
    oline = (4 * " ") + iline  # left margin
    olines.append(oline)
olines.extend(2 * [""])  # bottom margin

otext = "\n".join(olines) + "\n"
obytes = otext.encode()

+ func lowered
+ set -xe
+ bin/pq.py --py lowered

itext = ibytes.decode()
otext = itext.lower()  # lowered lowercased  # |tr '[A-Z]' '[a-z]'
obytes = otext.encode()

+ func lstripped
+ set -xe
+ bin/pq.py --py lstripped

itext = ibytes.decode()
ilines = itext.splitlines()
olines = list()
for iline in ilines:

    oline = iline.lstrip()  # lstripped  # |sed 's,^ *,,'
    olines.append(oline)

otext = "\n".join(olines) + "\n"
obytes = otext.encode()

+ func rstripped
+ set -xe
+ bin/pq.py --py rstripped

itext = ibytes.decode()
ilines = itext.splitlines()
olines = list()
for iline in ilines:

    oline = iline.rstrip()  # rstripped  # |sed 's, *$,,'
    olines.append(oline)

otext = "\n".join(olines) + "\n"
obytes = otext.encode()

+ func reversed
+ set -xe
+ bin/pq.py --py reversed

itext = ibytes.decode()
ilines = itext.splitlines()

olines = reversed(ilines)  # reverse  # |tail -r  # tail r  # |tac  # tac

otext = "\n".join(olines) + "\n"
obytes = otext.encode()

+ func sorted
+ set -xe
+ bin/pq.py --py sorted

itext = ibytes.decode()
ilines = itext.splitlines()

olines = sorted(ilines)  # sort  # s s

otext = "\n".join(olines) + "\n"
obytes = otext.encode()

+ func sponged
+ set -xe
+ bin/pq.py --py sponged

obytes = ibytes  # sponged  # sponge

+ func shuffled
+ set -xe
+ bin/pq.py --py shuffled

itext = ibytes.decode()
ilines = itext.splitlines()

olines = list(ilines); random.shuffle(olines)  # shuffled

otext = "\n".join(olines) + "\n"
obytes = otext.encode()

+ func stripped
+ set -xe
+ bin/pq.py --py stripped

itext = ibytes.decode()
ilines = itext.splitlines()
olines = list()
for iline in ilines:

    oline = iline.strip()  # stripped  # |sed 's,^ *,,' |sed 's, *$,,'
    olines.append(oline)

otext = "\n".join(olines) + "\n"
obytes = otext.encode()

+ func titled
+ set -xe
+ bin/pq.py --py titled

itext = ibytes.decode()
otext = itext.title()  # titled
obytes = otext.encode()

+ func undented
+ set -xe
+ bin/pq.py --py undented

itext = ibytes.decode()
ilines = itext.splitlines()
olines = list()
for iline in ilines:

    oline = iline.removeprefix(4 * " ")  # as if textwrap.undented  # undent
    olines.append(oline)

otext = "\n".join(olines) + "\n"
obytes = otext.encode()

+ func uppered
+ set -xe
+ bin/pq.py --py uppered

itext = ibytes.decode()
otext = itext.upper()  # uppered uppercased  # |tr '[a-z]' '[A-Z]'
obytes = otext.encode()

+ func tac
+ set -xe
+ bin/pq.py --py tac

itext = ibytes.decode()
ilines = itext.splitlines()

olines = reversed(ilines)  # reverse  # |tail -r  # tail r  # |tac  # tac

otext = "\n".join(olines) + "\n"
obytes = otext.encode()

+ func tail r
+ set -xe
+ bin/pq.py --py tail r

itext = ibytes.decode()
ilines = itext.splitlines()

olines = reversed(ilines)  # reverse  # |tail -r  # tail r  # |tac  # tac

otext = "\n".join(olines) + "\n"
obytes = otext.encode()

+ func uniq
+ set -xe
+ bin/pq.py --py uniq

itext = ibytes.decode()
ilines = itext.splitlines()

# collections.Counter.keys, set, uniq, uniq_everseen, unsorted
olines = list(dict((_, _) for _ in ilines).keys())

otext = "\n".join(olines) + "\n"
obytes = otext.encode()

+ func wc c
+ set -xe
+ bin/pq.py --py wc c

oline = str(len(ibytes))  # bytes len  # |wc -c  # wc c  # wcc

olines = [oline]
otext = "\n".join(olines) + "\n"
obytes = otext.encode()

+ func wc l
+ set -xe
+ bin/pq.py --py wc l

itext = ibytes.decode()

oline = str(len(itext.splitlines()))  # lines len  # |wc -l  # wc l  # wcl

olines = [oline]
otext = "\n".join(olines) + "\n"
obytes = otext.encode()

+ func wc m
+ set -xe
+ bin/pq.py --py wc m

itext = ibytes.decode()

oline = str(len(itext))  # text characters len  # |wc -m  # wc m  # wcm

olines = [oline]
otext = "\n".join(olines) + "\n"
obytes = otext.encode()

+ func wc w
+ set -xe
+ bin/pq.py --py wc w

itext = ibytes.decode()

oline = str(len(itext.split()))  # words len  # |wc -w  # wc w  # wcw

olines = [oline]
otext = "\n".join(olines) + "\n"
obytes = otext.encode()

+ func xargs
+ set -xe
+ bin/pq.py --py xargs
pq.py: 2 Py Grafs matched, not just 1, by ['xargs']

['oline = " ".join(ilines)  # joined  # |tr \'\\n\' \' \'  # |xargs  # x x']

['olines = itext.split()  # |xargs -n 1  # |xn1  # split']
+ echo + exit 2
+ exit 2
+ func a
+ set -xe
+ bin/pq.py --py a

itext = ibytes.decode()
ilines = itext.splitlines()
olines = list()
for iline in ilines:

    # |awk '{print $NF}'  # a a
    ilinewords = iline.split()
    oline = ilinewords[-1] if ilinewords else ""
    olines.append(oline)

otext = "\n".join(olines) + "\n"
obytes = otext.encode()

+ func s
+ set -xe
+ bin/pq.py --py s

itext = ibytes.decode()
ilines = itext.splitlines()

olines = sorted(ilines)  # sort  # s s

otext = "\n".join(olines) + "\n"
obytes = otext.encode()

+ func u
+ set -xe
+ bin/pq.py --py u

itext = ibytes.decode()
ilines = itext.splitlines()

# collections.Counter.keys, set, uniq, uniq_everseen, unsorted
olines = list(dict((_, _) for _ in ilines).keys())

otext = "\n".join(olines) + "\n"
obytes = otext.encode()

+ func x
+ set -xe
+ bin/pq.py --py x

itext = ibytes.decode()
ilines = itext.splitlines()

oline = " ".join(ilines)  # joined  # |tr '\n' ' '  # |xargs  # x x

olines = [oline]
otext = "\n".join(olines) + "\n"
obytes = otext.encode()

+ func wcl
+ set -xe
+ bin/pq.py --py wcl

itext = ibytes.decode()

oline = str(len(itext.splitlines()))  # lines len  # |wc -l  # wc l  # wcl

olines = [oline]
otext = "\n".join(olines) + "\n"
obytes = otext.encode()

+ func xn1
+ set -xe
+ bin/pq.py --py xn1

itext = ibytes.decode()

olines = itext.split()  # |xargs -n 1  # |xn1  # split

otext = "\n".join(olines) + "\n"
obytes = otext.encode()

+ echo +
+
